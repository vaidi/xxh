mysql索引
有序结果集：
1：fileSort
2：按索引顺序排序
索引结构
聚簇索引（一级索引）：节点页只包含了索引列，叶子页包含了行的全部数据。聚簇索引“就是表”，因此可以不需要独立行储存。
聚簇索引保证关键字的值相近的元组存储的物理 位置也相近
非聚簇索引(二级索引）：叶子节点保存的不是指行的物理位置的指针，而是行的主键值。（两次B-tree查找）
hash索引：基于哈希表实现只有精确索引所有列的查询才有效。（对每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希
索引将装有哈希码存储在一个索引中，同时子哈希表中保存指向的每个数据的指针）只有memory引擎支持hash索引
只是赢hash：InnoDB引擎，当I你弄DB注意到某些索引值被使用的非常频繁，它会在内存中基于缓冲池中的B+Tree索引上创建一个hash索引，
这样B-tree索引也具有哈希索引的一些优点。
全文索引：MyISAM的一个特殊索引

索引类型： 普通索引     唯一索引  主键索引  组合索引
索引失效： 列上进行计算  函数  or not in <>  !=

覆盖索引：
1：就是select的列只用从索引中就能够取得，不必从数据中读取，换句话 说查询列要被使用的索引覆盖。
2：是非聚簇组合索引的一种形式，它包括在查询的select，join和where子句用到的所有列（即建立索引的字段正好是覆盖查询语句【select子句】
与查询条件【where子句】中所设计到的字段，即索引包含了查询正在查找的数据


InnoDB-MVCC多版本并发控制 https://segmentfault.com/a/1190000012650596
Mysql引擎特性~Innodb事物系统  http://mysql.taobao.org/monthly/2017/12/01/

InnoDB的MVCC是通过在每行记录后面保存两个隐含列也有说三个来实现的。
read view 快照生成时机，在RR，RC两种不同的隔离级别下不可见性；
1：在innodb中RR级别，事物在begin/start transacction 之后的一个条select读操作后会创建一个快照（read view），将当前
系统中活跃的其他事物记录起来；RR级别下，快照是基于执行第一个读取操作的时间。
2：RC级别下，事物中每条select语句都会创建一个快照（read view），RC级别，快照被重置为每一个读取操作时间。

MVCC特点：
1：每行数据都存在一个版本，每次数据更新时都更新该版本
2：修改时copy出当前版本，然后随意修改，各个事物之间无干扰
3：保存时比较版本号，如果成功，则覆盖原记录，失败则放弃
4：就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道，因为这看起来正式，在提交的
时候才能到底能否提交成功。
实现mvcc方式：
1：事物以排它锁的形式修改原始数据
2：把修改前的数据存放在undo log，通过回滚指针与主数据关联
3：修改成功啥都不做，失败则恢复undo log中的数据（rollback）
二者本质区别是：当修改数据是否要排他锁，如果锁定了还算mvcc？
答:Innodb的实现算不上真正的MVCC，undo-log是串行化的，
一行的数据每问题，但当设计到多行数据，理想的mvcc就无能为力了。








RR级别下通过排它锁+MVCC 一起实现不仅可以保证可重复读，还可以保证部分幻读，而非完全防止；
原因：在如果事物B在事物A执行中，insert了一条数据并提交，事物A再次查询，虽然时undo中的旧版本数据（防止了部分幻读）
，但是事物A中执行update或者delete都是可以成功的，在innodb中的操作可以分为当前读和快照读。

快照读：简单的select操作（当然不包括lock in share mode，for update）
当前读：innodb在快照读的情况下并没有真正的避免幻读，但是当前读的情况下避免了不可重复读和幻读
（问题：select id >1 然后执行delete id=5  然后再执行select  id>1 查看条数  幻读问题会不会产生） 




Undo-log的知识点
1：Undo-log是innodb mvcc事物特性的重要 组成部分，当我们对记录做了变更操作时会产生undo记录，Undo记录默认被记录
到系统表空间中，但从5.6开始，也可以使用独立的Undo表空间
2：Undo记录中存储的时老版本数据，当一个旧的事物需要读取数据时，为了能读取到老版本的数据，顺着undo链找到满足可见
性的记录，当版本的链很长时，通常可认为这是个比较耗时的操作






















