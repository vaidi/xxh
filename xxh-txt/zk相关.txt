zk的使用场景;
1:分布式协调
2：分布式锁
3：元数据/配置信息管理
4：HA高可用性

zk分布式锁：
就是某个节点尝试创建临时znode，此时 创建成功了就获取了这个锁；这个时候别的客户端来创建失败，只能注册个监听器监听这个锁，释放锁就是删除这个znode，
一单释放掉就会通知某个客户端，然后有一个等待着的客户端就可以再次重新加锁。

1：创建一个临时有序的临时节点，A创建/xx/001  的临时节点，并遍历/xx下面的所有子节点，发现001最小的子节点就获取锁
2：C创建/xx/003 ，并遍历/xx下面的所有临时节点  看自己是不是最小的，不是最小的给比自己小一号的创建一个监听器，只要监听到节点被删除也就释放，获取锁。





redis分布式锁：
要不停的while循环调用加锁
看门狗机制：自动延期机制 客户端加锁key默认时间才30秒，如果超过了30秒，当前客户端还想一直持有这把锁，只要客户端一旦检查加锁成功，就会启动一个watch dog
，她是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断延长key的生存 时间。

zk的watch机制：
1：watches通知是一次性的，必须重复注册。
2：发生connectionloss之后 ，只要在session_timne之后再次链接上（即不发生sessionexpired），那么这个链接注册的watches依然在。
3：对某个节点注册了watch，但是节点被删除了，那么注册在这个节点的watches都会被移除。
4：同一个zk客户端对某一个节点注册相同的watch，只会收到一次通知。
6：watch对象只会保存在客户端，不会传递到服务端。


zk的选举机制：  针对的是FastLeaderElection选举模式
1：zk集群中只有 超过半数以上的服务器启动，集群才能正常工作，
2：在集群正常工作之前，myid小的 服务器给myid大的服务器投票，直到集群正常工作 ，选出leader，
3：选出leader之后，之前的服务器状态由looking改为following，以后的服务器都是follower。
概念：
1：serverid：服务器id  编号越大，权重越大
2：zxid：数据id  值越大说明数据越新，在选举算法中权重越大
3：Epoch：逻辑时钟 或者叫投票次数，同一轮投票过程中的逻辑时钟值是相同的，每投完一次票就会增加，然后与接受到的其他服务器返回的投票信息中的数值
相比，根据不同的值做出不同的判断。
4：选举状态  LOOKING FOLLOWING  OBSERVING LEADING 



zookeeper有哪些功能？
1：集群管理：监控节点存活状态，运行请求等。
2：主节点选举：主节点挂掉了之后可以从 备用的节点开始新 一轮选主，主节点选举说的就是这个选举的过程，使用zookeeper可以协助 完成这个过程。
3：分布式锁：zk提供了两种锁：独占锁，共享 锁。独占 锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，既可以有多线程同时读取同一个资源
 如果要使用写锁也只能有一个线程使用，zookeeper可以对分布式锁进行控制。
4：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。

zookeeper怎么 保证主从节点的状态同步 ？
zookeeper的核心是原子广播，这个机制保证了 各个server之间的同步，实现这个机制协议 叫做zab协议，zab协议有两种模式，分别是恢复模式（选主）和 广播模式
（同步），当服务启动或者 在领导者崩溃后，zab就进入了恢复模式，当领导被选举出来，且大多数server完成了和leader的状态同步以后，恢复模式就结束了。状态
同步保证了leader和server具有相同的系统状态。































