zk的使用场景;
1:分布式协调
2：分布式锁
3：元数据/配置信息管理
4：HA高可用性

zk分布式锁：
就是某个节点尝试创建临时znode，此时 创建成功了就获取了这个锁；这个时候别的客户端来创建失败，只能注册个监听器监听这个锁，释放锁就是删除这个znode，
一单释放掉就会通知某个客户端，然后有一个等待着的客户端就可以再次重新加锁。

1：创建一个临时有序的临时节点，A创建/xx/001  的临时节点，并遍历/xx下面的所有子节点，发现001最小的子节点就获取锁
2：C创建/xx/003 ，并遍历/xx下面的所有临时节点  看自己是不是最小的，不是最小的给比自己小一号的创建一个监听器，只要监听到节点被删除也就释放，获取锁。





redis分布式锁：
要不停的while循环调用加锁
看门狗机制：自动延期机制 客户端加锁key默认时间才30秒，如果超过了30秒，当前客户端还想一直持有这把锁，只要客户端一旦检查加锁成功，就会启动一个watch dog
，她是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断延长key的生存 时间。

zk的watch机制：
1：watches通知是一次性的，必须重复注册。
2：发生connectionloss之后 ，只要在session_timne之后再次链接上（即不发生sessionexpired），那么这个链接注册的watches依然在。
3：对某个节点注册了watch，但是节点被删除了，那么注册在这个节点的watches都会被移除。
4：同一个zk客户端对某一个节点注册相同的watch，只会收到一次通知。
6：watch对象只会保存在客户端，不会传递到服务端。


zk的选举机制：  针对的是FastLeaderElection选举模式
1：zk集群中只有 超过半数以上的服务器启动，集群才能正常工作，
2：在集群正常工作之前，myid小的 服务器给myid大的服务器投票，直到集群正常工作 ，选出leader，
3：选出leader之后，之前的服务器状态由looking改为following，以后的服务器都是follower。
概念：
1：serverid：服务器id  编号越大，权重越大
2：zxid：数据id  值越大说明数据越新，在选举算法中权重越大
3：Epoch：逻辑时钟 或者叫投票次数，同一轮投票过程中的逻辑时钟值是相同的，每投完一次票就会增加，然后与接受到的其他服务器返回的投票信息中的数值
相比，根据不同的值做出不同的判断。
4：选举状态  LOOKING FOLLOWING  OBSERVING LEADING 

















