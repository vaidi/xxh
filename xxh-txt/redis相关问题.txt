redis线程模型：
单线程工作模型，采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。
多个socket可能会并发产生不同的操作，每个操作对应不同的 文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队。
事件分配器每次从队列中取出一个事件，把该事件交给对应的事件处理器处理。


一致性哈希的四个重要特征：
均衡性：也有人把它定义为平衡性，是指哈希的结构能够尽可能分布在所有的节点中去，这样可以有效的利用每个节点上资源。
单调性：当节点数量变化时哈希的结果应尽可能的保护分配的内容不会被重新分派到性能的节点
分散性和负载：这两个其实是差不多的意思，就是要求一致性哈希算法对key哈希尽可能避免重复。

Redis集群数据
redis集群使用数据分片而非一致性来实现：一个redis集群包含16384个哈希槽，数据库中的每个键都属于这16384个哈希槽的其中的一个，集群使用crc16（key）%16384
来计算key属于哪个槽，其中crc16（key）语句用于计算建key的crc16校验和。
因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞，所以无论是添加节点还是移除存在节点又或者改变某个节点不包含的哈希槽数量，都不会造成集群下线。
Redis集群不保证数据的强一致性：在特定条件下，redis集群可能会丢失已经执行过的写命令。使用异步复制是redis集群可能会丢失写命令的其中一个原因。


集群中的所有信息，都通过节点之间定期的数据交换而更新，Redis客户端可以再任意一个redis实例发出请求，如果所需数据不在该实例中，通过重定向命令引导客户端
访问 所需要的实例。

实现数据分片(集群)方式大致有三种： 
1）客户端实现数据分片
2）服务器实现数据分片
3）通过代理服务器实现数据分片





redis过期设置：

定期删除： redis默认是每隔100ms就随机一些设置了过期时间的key。

惰性删除：定期删除可能会很多过期key到了时间并没有被删除掉。

Reids内存淘汰机制

1：volatile-lur：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰机制。
2：volatile-ttl:从已设置过期时间的数据集中挑选将要过期的数据。
3：volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。
4：allkeys-lru:当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个最常用）
5：allkeys-random:从数据集中任意选择数据淘汰
6：no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。
7：volatile-lfu:从已设置过期时间的数据集中挑选最不经事使用的数据淘汰
8：allkeys-lfu：当内存不足已容纳新写入数据时，在键空间中，移除最不经常使用的key



缓存雪崩：缓存同一时间大面积的失效，所以后面的请求都会落到 数据库上，造成数据库短时间内承受大量请求而崩掉。

缓存穿透：大量请求的key根本不存在缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。


Redis数据存储结构：
redis的内部整体的存储结构就是一个大的hashmap,内部实现的是数组实现hash，冲突通过挂链去实现，然后每个dictEntry就是一个key/value对象。
DictEnty的key指向set key value命令中的key对应的对象，dictEntry的v指向set key value对应的对象。
dictEntry内部存储的key和v变量，同时包含一个dictEntry的next指针链接落入同一个hash桶的对象。dictEntry当中的key和v的指针指向的是redisObject。









持久化机制：

RDB:快照  redis可以通过创建快照来获取存储在内存里的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到
其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高reids的性能，读写分开什么的），还可以将快照留在原地以便重启服务 
的时候用。
优点：
1：RDB是一个非常紧凑的文件，它保存了Reids在某个时间点上的数据集。
2：RDB非常适用于灾难恢复，它只有一个文件并且内容都非常紧凑，可以（加密后）将它传送到别的数据中心
3：RDB可以最大Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后将这个子进程就会处理接下来的所有保存工作 ，父进程无需执行任何磁盘I/O操作。
4：恢复大数据集的时候速度快。
缺点：
1：如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率，
 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下，
 一旦发生故障停机， 你就可能会丢失好几分钟的数据。

2：每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，
造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。
 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。



AOF:只追加文件  与快照持久化相比，AOF持久化的实时性更好，因此已成为主流的持久化方案，开启AOF持久化后每执行一条会更改redis中的数据的命令
，redis就会将该命令写入硬盘中的aof文件，Aof文件的保存位置和rdb的位置相同，都是dir参数配置的，默认文件名时appendonly.aof。

优点：
1：使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，
或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，
也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。
2:AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ，
即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。

3:Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 
整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，
现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。

4:AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂，对文件进行
分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态



copy and write技术实现原理：

fork（）之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程，当父进程只读内存时，相安无事，当其中某个进程写内存
时，cpu硬件检测到内存页是read-onlu的，于是触发页异常中断，陷入kernel的一个中断例成，中断例程中，kernel就会把触发的异常复制一份，于是父子进程
各自持有独立的一份。

优点：
1：cow技术可减少分配和复制资源时带来的瞬间延时。
2：cow技术可减少不必要的资源分配，比如fork进程时，并不是所有的页面都需要复制，父进程的代码段和只读段都不允许修改，所以无需复制。


cow的技术只能保证数据最终一致，不能保证数据的实时一致性。如果你希望写入的数据马上能读到，请不要使用cow容器。






和缓存穿透牵连在一起的布隆过滤器
原理：当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组的K个点，把他们设置为1,检索的时候如果发现是0就存在，1就是不存在。
缺点是：存在误判，删除困难


Redis内存结构

string：reids的字符串叫着sds，简单动态字符串，它的结构是一个带长度信息的字节数组。
为什么不使用C语言字符串实现，而是使用SDS？
1：常数复杂度获取字符串长度，查询O（1）
2：杜绝缓冲区溢出
3：减少修改字符串的内存重新分配次数
4：二进制安全
5：兼容部分c字符串函数




杜绝缓冲区溢出：当我们需要对一个sds进行修改的时候，redis会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会扩张sds的空间，然后再执行拼接操作。






Redis链表特性：
1：双端：链表具有前置节点和后置节点的引用，获取这两节点时间复杂度都为O（1）
2：无环：表头节点的prev指针和表尾节点的next指针都指向null，对链表的访问都是以null结束。
3：带链表长度计数器：通过len属性获取链表长度的时间复杂度为（1）
4：多态：链表节点使用void*指针来保存节点值，可以保存各种不同类型的值。

重点：
1：链表被广泛 用于实现redis的各种功能，比如列表键，发布和订阅，慢查询，监视器
2：每个链表的节点都有一个listNode结构来表示，每个节点都有一个指向前置节点和猴子节点的指针，所以redis的链表实现双端链表
3：每个链表使用一个list结构来表示，这个结构带有表头节点指针，表尾节点指针，以及链表长度等信息
4：因为链表表头节点和标位节点的都指向null，所以redis的链表实现是无环链表
5：通过链表设置不同类型特定函数，redis的链表可以用来保存不同类型的值。





字典：又称为符号表或者关联数组或映射，是一种用于保存键值对的抽象数据结构，字典中的每一个key都是唯一的，通过key可以对值进行查找或者修改。
底层用的哈希表作为底层实现。
MurmurHash 算法最初由 Austin Appleby 于 2008 年发明， 这种算法的优点在于， 即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性，
 并且算法的计算速度也非常快。
解决键冲突：链地址法来解决键冲突：每个哈希表都有一个next指针，多个hash表可以用next指针构成一个单向链表，被分配到一个索引上的多个节点可以用这个
单向链表链接起来解决键冲突（类似于hashmap），因为dictEntry节点组成的链表没有指向链表表位的指针，所以为了速度考虑，程序总是将 新节点加到链表的表头位置
复杂度为o（1），排在其他的已有节点的前；
rehash（重新散列）





跳跃表：是一种有序的数据结构，它通过每个节点中维持多个指向其它节点的指针，从而到快速访问节点的目的。
1：有很多层结构组成
2：每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点。
3：最底层的链表包含了所有的元素
4：如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层元素是当前层元素的子集）
5：链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点。
搜索：从最高层的链表节点开始，如果当前节点要大和比当前层的下一个节点小，那么则往下找，也就是和当前层的下一层节点的下一个节点进行比较，以此类推，一直
找到最底层的最后一个节点，如果找到则返回，反之则返回为空。
插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数，当确定插入的层数k后，则需要
将新插入的从底层到k层。
删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除 以后只剩下头尾两个节点，则删除这一层。


整数集合：redis用于保存整数值的集合抽象数据类型，它可以保证类型 为int16_t，int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。
升级：当我们新增的元素类型比原集合袁术类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中，
1：根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。
2：将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的，
3：将新元素添加到整数集合中。
降级：整数结合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。



压缩列表：redis为了节省内存而开发的，是有一系列特殊编码的连续内存模块组成的顺序型数据结构，一旦压缩表可以包含任意多个节点，每个节点 
可以保存一个直接数组或者一个整数集。原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的 内存区域，目的是为了节省内存。





























问题一：
1：缓存不一致： 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。  更新数据时候，先更新数据库，
然后再删除缓存。

2：为什么reids单线程模型也能效率这么高？存内存操作， 核心是基于非阻塞的io多路复用机制。c语言实现的，单线程反而避免了多线程的频繁上下文切换问题
预防了多线程可能产生的竞争问题。

3：流量很大导致的缓存不一致：更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个jvm内部队列中。读取数据的时候如果发现数据不在缓存中
那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个jvm内部队列中。一个队列对应一个工作线程，每个工作线程串行拿到
对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新，此时如果一个读请求过来，没有
读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。

4：redis并发问题：时间戳+zk锁来解决


5：redis为什么是单线程？
因为Reids是基于内存的操作，cpu不是Redis的瓶颈，redis的瓶颈 最有可能是机器内存的大小或者网络宽带，既然单线程容易实现，而且cpu不会成为瓶颈，那就
顺理成章地采用单线程的方案，reids利用队列技术将并发访问变成串行访问。绝大部分请求是纯粹的内存操作，采用单线程避免了不必要的上下文切换和竞争条件
，非阻塞IO优点：速度快   支持丰富的数据类型  支持事务 














































