redis线程模型：
单线程工作模型，采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。
多个socket可能会并发产生不同的操作，每个操作对应不同的 文件事件，但是IO多路复用程序会监听多个socket，
会将socket产生的事件放入队列中排队。
事件分配器每次从队列中取出一个事件，把该事件交给对应的事件处理器处理。


一致性哈希的四个重要特征：
均衡性：也有人把它定义为平衡性，是指哈希的结构能够尽可能分布在所有的节点中去，这样可以有效的利用每个节点上资源。
单调性：当节点数量变化时哈希的结果应尽可能的保护分配的内容不会被重新分派到性能的节点
分散性和负载：这两个其实是差不多的意思，就是要求一致性哈希算法对key哈希尽可能避免重复。

Redis集群数据
redis集群使用数据分片而非一致性来实现：一个redis集群包含16384个哈希槽，数据库中的每个键都属于这16384个哈希槽的其中的一个，
集群使用crc16（key）%16384来计算key属于哪个槽，其中crc16（key）语句用于计算建key的crc16校验和。
因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞，所以无论是添加节点还是移除存在节点又
或者改变某个节点不包含的哈希槽数量，都不会造成集群下线。
Redis集群不保证数据的强一致性：在特定条件下，redis集群可能会丢失已经执行过的写命令。
使用异步复制是redis集群可能会丢失写命令的其中一个原因。


集群中的所有信息，都通过节点之间定期的数据交换而更新，Redis客户端可以再任意一个redis实例发出请求，如果所需数据不在该实例中，
通过重定向命令引导客户端访问 所需要的实例。

实现数据分片(集群)方式大致有三种： 
1）客户端实现数据分片
2）服务器实现数据分片
3）通过代理服务器实现数据分片





redis过期设置：
定期删除： redis默认是每隔100ms就随机一些设置了过期时间的key。
惰性删除：定期删除可能会很多过期key到了时间并没有被删除掉。

Reids内存淘汰机制

1：volatile-lur：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰机制。
2：volatile-ttl:从已设置过期时间的数据集中挑选将要过期的数据。
3：volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。
4：allkeys-lru:当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个最常用）
5：allkeys-random:从数据集中任意选择数据淘汰
6：no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。
7：volatile-lfu:从已设置过期时间的数据集中挑选最不经事使用的数据淘汰
8：allkeys-lfu：当内存不足已容纳新写入数据时，在键空间中，移除最不经常使用的key



Redis数据存储结构：
redis的内部整体的存储结构就是一个大的hashmap,内部实现的是数组实现hash，冲突通过挂链去实现，
然后每个dictEntry就是一个key/value对象。
DictEnty的key指向set key value命令中的key对应的对象，dictEntry的v指向set key value对应的对象。
dictEntry内部存储的key和v变量，同时包含一个dictEntry的next指针链接落入同一个hash桶的对象。
dictEntry当中的key和v的指针指向的是redisObject。

redis锁相关写的特别赞的一篇文章
https://blog.csdn.net/qq_39035267/article/details/129236671






持久化机制：

RDB:快照  redis可以通过创建快照来获取存储在内存里的数据在某个时间点上的副本。
Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本\
（Redis主从结构，主要用来提高reids的性能，读写分开什么的），还可以将快照留在原地以便重启服务的时候用。
优点：
1：RDB是一个非常紧凑的文件，它保存了Reids在某个时间点上的数据集。
2：RDB非常适用于灾难恢复，它只有一个文件并且内容都非常紧凑，可以（加密后）将它传送到别的数据中心
3：RDB可以最大Redis的性能：父进程在保存RDB文件时唯一要做的就是fork出一个子进程，然后将这个子进程就会处理接下来的所有保存工作 ，
父进程无需执行任何磁盘I/O操作。
4：恢复大数据集的时候速度快。
缺点：
1：如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率，
 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下，
 一旦发生故障停机， 你就可能会丢失好几分钟的数据。

2：每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，
造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。
 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。



AOF:只追加文件  与快照持久化相比，AOF持久化的实时性更好，因此已成为主流的持久化方案，开启AOF持久化后每执行一条会更改redis中的数据的命令
，redis就会将该命令写入硬盘中的aof文件，Aof文件的保存位置和rdb的位置相同，都是dir参数配置的，默认文件名时appendonly.aof。


写回策略：（aof文件的内存缓冲去）
1,always
2,no  操作系统
3，everysec  每秒 （宕机时丢弃前一秒数据）
优点：
1：使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，
或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，
也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。
2:AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ，
即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。

3:Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 
整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，
现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。

4:AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂，对文件进行
分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态

5：aof重写缓冲区，aof重写客户端的命令都写到aof重写缓冲区中。


copy and write技术实现原理：

fork（）之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程，当父进程只读内存时，相安无事，
当其中某个进程写内存时，cpu硬件检测到内存页是read-only的，于是触发页异常中断，陷入kernel的一个中断例成，中断例程中，
kernel就会把触发的异常复制一份，于是父子进程各自持有独立的一份。

优点：
1：cow技术可减少分配和复制资源时带来的瞬间延时。
2：cow技术可减少不必要的资源分配，比如fork进程时，并不是所有的页面都需要复制，父进程的代码段和只读段都不允许修改，所以无需复制。


cow的技术只能保证数据最终一致，不能保证数据的实时一致性。如果你希望写入的数据马上能读到，请不要使用cow容器。






和缓存穿透牵连在一起的布隆过滤器
原理：当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组的K个点，把他们设置为1,
检索的时候如果发现是0就存在，1就是不存在。
缺点是：存在误判，删除困难.误判存在，可判断一定不存在


Redis内存结构

string：reids的字符串叫着sds，简单动态字符串，它的结构是一个带长度信息的字节数组。
为什么不使用C语言字符串实现，而是使用SDS？
1：常数复杂度获取字符串长度，查询O（1）
2：杜绝缓冲区溢出
3：减少修改字符串的内存重新分配次数
4：二进制安全
5：兼容部分c字符串函数

杜绝缓冲区溢出：当我们需要对一个sds进行修改的时候，redis会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会扩张sds的空间，然后再执行拼接操作。



raft 算法
集群16384 个槽
1、hash取模
2、一致性hash算法（缺点数据倾斜）

一、删除策略
删除策略就是针对已过期数据的处理策略。

针对过期数据要进行删除的时候都有哪些删除策略呢？

1.定时删除
2.惰性删除
3.定期删除
 1、立即删除

当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。

优点：节约内存，到时就删除，快速释放掉不必要的内存占用
缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量
总结：用处理器性能换取存储空间（拿时间换空间）
 2、惰性删除

数据到达过期时间，不做处理。等下次访问该数据时，判断
1. 如果未过期，则返回数据
2. 发现已过期，删除，返回不存在

优点：节约CPU性能，发现必须删除的时候才删除
缺点：内存压力很大，出现长期占用内存的数据
总结：用存储空间换取处理器性能（拿空间换时间）
3、定期删除
Redis启动服务器初始化时，读取配置server.hz的值，默认为10
每秒钟执行server.hz次serverCron()-------->databasesCron()--------->activeExpireCycle()
activeExpireCycle()对每个redis库逐一进行检测，每次执行耗时：250ms/server.hz
对某个库检测时，随机挑选W个key检测
        （1）如果key超时，删除key
        （2）如果一轮中删除的key的数量>W*25%，循环该过程
        （3）如果一轮中删除的key的数量≤W25%，检查下一个库，在0-15库之间循环
           W取值=ACTIVEEXPIRECYCLE_LOOKUPSPERLOOP属性值

二、淘汰策略
当新数据进入redis时，如果内存不足，就会引发淘汰机制。
影响数据淘汰的相关配置如下：
1：最大可使用内存，即占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上
properties maxmemory ?mb
2：每次选取待删除数据的个数，采用随机获取数据的方式作为待检测删除数据
properties maxmemory-samples count

3：对数据进行删除的选择策略
properties maxmemory-policy policy

数据淘汰的策略一共有3种：
1、检测易失数据（设置了过期时间的数据）

volatile-lru：挑选最近最少使用的数据淘汰
volatile-lfu：挑选最近使用次数最少的数据淘汰
volatile-ttl：挑选将要过期的数据淘汰
volatile-random：任意选择数据淘汰

2、检测全库数据

allkeys-lru：挑选最近最少使用的数据淘汰
allkeLyRs-lfu：：挑选最近使用次数最少的数据淘汰
allkeys-random：任意选择数据淘汰，相当于随机

3、放弃数据驱逐

no-enviction（驱逐）：禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out Of Memory)


Redis链表特性：
1：双端：链表具有前置节点和后置节点的引用，获取这两节点时间复杂度都为O（1）
2：无环：表头节点的prev指针和表尾节点的next指针都指向null，对链表的访问都是以null结束。
3：带链表长度计数器：通过len属性获取链表长度的时间复杂度为（1）
4：多态：链表节点使用void*指针来保存节点值，可以保存各种不同类型的值。
重点：
1：链表被广泛 用于实现redis的各种功能，比如列表键，发布和订阅，慢查询，监视器
2：每个链表的节点都有一个listNode结构来表示，每个节点都有一个指向前置节点和猴子节点的指针，所以redis的链表实现双端链表
3：每个链表使用一个list结构来表示，这个结构带有表头节点指针，表尾节点指针，以及链表长度等信息
4：因为链表表头节点和标位节点的都指向null，所以redis的链表实现是无环链表
5：通过链表设置不同类型特定函数，redis的链表可以用来保存不同类型的值。


内存碎片问题？
info memory


字典：又称为符号表或者关联数组或映射，是一种用于保存键值对的抽象数据结构，字典中的每一个key都是唯一的，通过key可以对值进行
查找或者修改。底层用的哈希表作为底层实现。
MurmurHash 算法最初由 Austin Appleby 于 2008 年发明， 这种算法的优点在于， 即使输入的键是有规律的，
 算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。
解决键冲突：链地址法来解决键冲突：每个哈希表都有一个next指针，多个hash表可以用next指针构成一个单向链表，
被分配到一个索引上的多个节点可以用这个
单向链表链接起来解决键冲突（类似于hashmap），因为dictEntry节点组成的链表没有指向链表表位的指针，所以为了速度考虑，
程序总是将 新节点加到链表的表头位置
复杂度为o（1），排在其他的已有节点的前；
rehash（重新散列）


1、缓存预热
2、缓存雪崩：大面积key失效。 随机时间，多缓存，服务降级
3、缓存穿透:redis和数据库都没有 每次都达到数据库上。解决方式：空对象，布隆过滤器
4、缓存击穿:热点（大qps）key突然失效。双检加锁，双缓存机制（保存的过期时间不一样）




跳跃表：是一种有序的数据结构，它通过每个节点中维持多个指向其它节点的指针，从而到快速访问节点的目的。
1：有很多层结构组成（l1-l32）
2：每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点。
3：最底层的链表包含了所有的元素
4：如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层元素是当前层元素的子集）
5：链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点。
搜索：从最高层的链表节点开始，如果当前节点要大和比当前层的下一个节点小，那么则往下找，也就是和当前层的下一层节点的下一个节点进行比较，以此类推，一直
找到最底层的最后一个节点，如果找到则返回，反之则返回为空。
插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数，当确定插入的层数k后，则需要
将新插入的从底层到k层。
删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除 以后只剩下头尾两个节点，则删除这一层。


整数集合：redis用于保存整数值的集合抽象数据类型，它可以保证类型 为int16_t，int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。
升级：当我们新增的元素类型比原集合元术类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中，
1：根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。
2：将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的，
3：将新元素添加到整数集合中。
降级：整数结合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。



压缩列表：redis为了节省内存而开发的，是有一系列特殊编码的连续内存模块组成的顺序型数据结构，一旦压缩表可以包含任意多个节点，每个节点 
可以保存一个直接数组或者一个整数集。原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的 内存区域，
 目的是为了节省内存。

hashSet 是压缩列表和散列表


bigkey的问题 string10kb内 其他 元素个数不超过5000？
内存不均迁移困难
1、查看内存：memory useage
2、scan 扫描命令替代keys* 这个命令
3、--bigkeys 查询最大占用的字节
4、unlink 删除 渐进式删除

1、sds动态字符串
编码：int, emtstr，raw
embstr编码将创建字符串对象所需要的内存分配次数从raw的2次降为1次
embstr字符串对象只需要调用一次内存 释放函数，而raw则调用两次内存释放函数
保存在一块连续的内存里，embstr对象是只读的，如果修改就会变成raw。
动态字符串优点：
1，常数复杂度获取字符串长度。
2，杜绝缓冲区溢出。
3，减少修改字符串长度时所需的内存重分配次数 (空间预分配，惰性空间释放)
4，二进制安全。
5，兼容部分C字符串函数

2、双向链表 listnode结构
优点：
双端：链表都有prev和next
无环：表头的prev和表位的next都指向null
带表头指针和表尾指针
带链表长度计数器
多态：链表节点使用void* 指针来保存节点值，并且可以通过list结构的dup，free，match三个属性为节点值设置特定函数，所以链表
可以用来保存各种不同的值
应用场景： 列表键，发布订阅，慢查询，监视器

3、压缩列表:连锁更新现象
压缩列表是一种节约内存而开发的顺序型数据结构，
连锁更新问题

4、hash表
5、跳表
应用场景：有序集合，集群节点内部数据结构
结构： zskiplist 和zskiplistNode  zskiplist包含header，tail，level，length
zskiplistNode单独的跳变节点：level层（前进指针和跨度），bw后退指针，分值，成员对象
重点：每个跳跃表的节点都是1-32层的随机数
同一个跳跃表中多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的

6、整数集合
当一个集合只包含整数值原属，并且这个集合的原属数量不多时，redis会使用整数集合作为底层实现。
底层实现：
底层实现为数组，这个数组以有序，无抽工夫的方式保存，在有需要时，程序会根据新添加的原属类型改变这个数组的类型。

7、快速列表


8、紧凑列表
列表（list）： ziplist 或者linkedlist
ZSET:6 跳表+压缩列表 （使用压缩列表条件 集合长度小于64 每个原属小于64字节）
 7 跳表+紧凑列表
hash：6 压缩列表 （ziplist）+hashtable  7紧凑列表+hashtable

redisObject: 类型（字符串，列表对象，哈希表。。），编码，指向底层实现的数据结构类型的指针

内存回收使用的引用计数，redisObj 有一个refcount类型
对象共享（多个键引用同一个值， redis只对包含整数值的字符串对象进行共享0-9999）
对象空转时长：lru记录对象最后一次被程序访问的时间（object idletime）


混合持久化：
rdb恢复数据快，但是rdb效率不好把握
1,当开启混合持久化，在aof重写日志时，fork出来的重写子进程会先将与主进程共享的内存数据，以rdb的方式写入到aof文件中
2，然后主进程处理的操作命令，会被记录在重写缓冲区里，重写缓冲区的增量命令会以aof的方式进入aof文件
3，写入完成后，子进程通知主进程将新的含有rdb和aof格式的aof文件替换旧的aof文健


渐进式扩容
状态机

utv/cachecloud 搜狐的redis
http://www.52im.net/thread-1968-1-1.html redis知乎网





问题一：
1：缓存不一致： 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。  更新数据时候，先更新数据库，
然后再删除缓存。

2：为什么reids单线程模型也能效率这么高？存内存操作， 核心是基于非阻塞的io多路复用机制。c语言实现的，单线程反而避免了多线程的频繁上下文切换问题
预防了多线程可能产生的竞争问题。

3：流量很大导致的缓存不一致：更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个jvm内部队列中。读取数据的时候如果发现数据不在缓存中
那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个jvm内部队列中。一个队列对应一个工作线程，每个工作线程串行拿到
对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新，此时如果一个读请求过来，没有
读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。

4：redis并发问题：时间戳+zk锁来解决


5：redis为什么是单线程？
因为Reids是基于内存的操作，cpu不是Redis的瓶颈，redis的瓶颈 最有可能是机器内存的大小或者网络宽带，既然单线程容易实现，而且cpu不会成为瓶颈，
那就顺理成章地采用单线程的方案，reids利用队列技术将并发访问变成串行访问。绝大部分请求是纯粹的内存操作，
采用单线程避免了不必要的上下文切换和竞争条件，非阻塞IO优点：速度快   支持丰富的数据类型  支持事务


redis中的rehash浅析
1，redis中有一个全局hash表，该hash表中保存锁所有的键值对，hash表中的每一个元素称为哈希桶（bucket），哈希桶中保存了键值对以及对应next指针数据。
2，存在两个全局hash表，数据copy到hash table1时 hash table1仍然对客户端提供服务，
负载因子 = 哈希表已保存节点数量/哈希表大小

rehash期间，dict的操作如下
增：仅添加在 h[1]中
删：从ht[0]中找到则删除ht[0],如果找不到则到ht[1]中删除
查：从ht[0]中查，查不到再从ht[1]查
该：先查（会查两个表） 再修改节点

为了防止有的kv长时间不访问一直不迁移到ht[1],会定时去rehash，每次迁移100个



redis的槽为甚要用16384 2的14 次方  而crc16算法是2的16次方 65536？
1、发送心跳包的问题 65536 发送的心跳包大为8kb 而16384 则是2kb
2、节点不可能超过1000
3、槽位越少，压缩越小容易传输

查找大key命令
redis-cli --bigkeys -a 111


redis 事务的理解？ 更像一系列的批量命令
1、本质一组命令的集合，一次性的顺序性的排他性的执行列队中的命令
2、开启事务 muti命令 exec执行事务 discard 取消事务 watch 监视 unwatch取消监视
3、存在一个语法错误则全部回滚，否则只是一条数据执行不成功，中间实际是装入到一个队列中了
4、redis事务是服务器端实现的，当用户执行muti命令时，服务器对应的将客户端对象设置为一个专门的状态
此状态下所有后续执行命令都不胡玉被执行而是放在一个事务队列中。
5,语法错误 才连坐，其他时候不保证原子性
6,watch  的时候也会引发连做


nio:用户不断轮询询问内核数据，读不到返回空闲中的标识
io多路复用：一个进程处理多个链接，select,poll,epoll
epoll:将链接信息和事件放到队列中，一次放到事件分配器，事件分配器分发给事件处理器


redission 读写锁 和ReentrantReadWriteLock 读写锁的区别？锁原理


redission的算法  先判断存在，在判断 是否是当前线程 hset数据类型
KEYS[1] ： 锁名称
ARGV[1]： 锁失效时间
ARGV[2]： id + “:” + threadId; 锁的小key
"if (redis.call('exists', KEYS[1]) == 0) then " +
     "redis.call('hset', KEYS[1], ARGV[2], 1); " +
     "redis.call('pexpire', KEYS[1], ARGV[1]); " +
     "return nil; " +
 "end; " +
 "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
     "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
     "redis.call('pexpire', KEYS[1], ARGV[1]); " +
     "return nil; " +
 "end; " +
 "return redis.call('pttl', KEYS[1]);"




































