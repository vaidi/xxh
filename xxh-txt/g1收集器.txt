TLAB为线程本地分配缓冲区，它的目的为了防使使用对象尽可能快的分配出来，如果对象在一个共享的空间中分配，
我们需要采用一些同步机制来管理这些空间内的的空闲空间指针，在Eden空间中，每一个线程都有一个固定的分区
用于分配对象，即TLAB，分配对象时，线程之间不需要进行任何同步。

初始标记：在此阶段G1 GC对根进行标记，该阶段与常规（STW）年轻代垃圾回收密切相关。
G1 gc在初始阶段标记的存活区域扫描对老年代的引用，并标记被引用的对象，



除上面的引用类的方式，所有引用类的方式都不会触发初始化，称为被动引用。
1：通过子类引用父类的静态字段，不会导致初始化
2：通过数组定义引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的，
直接继承自Object的子类，其中包含了数组的属性和方法。
3：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

加载三件事：
1：通过一个类的全限定名来获取定义此类的二进制字节流。
2：将这个字节流所代表的静态存储结构转化为方法去的运行时数据存储。
3：在内存中生成一个代表这个类的Class对象，作为方法区这个类的各个数据的访问入口。

其中二进制字节流可以从以下方式中获取：
1：从zip包获取，这很常见，最终成为JAR,EAR,WAR格式的基础。
2：从网络中获取，这种常见最典型的应用是Applet
3：运行时计算生成，这种场景使用的最多得就是动态代理技术，在java。lang.reflect.Proxy中，就是用代理类的二进制字节流。
4：由其他文件生成，典型场景时JSP应用，即由jsp文件生成对应的Class类。
4：从数据库读取，这种场景相对少见，例如有些中间服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。

验证：
1：文件格式验证：验证字节流是否符合Class文件格式规范，并且能被当前版本的虚拟机处理。
2：元数据验证：对字节流描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。
3：字节码验证：通过数据流和控制分析，确保程序语义是合法，符合逻辑的。
4：符号引用验证：发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外的信息进行匹配性校验。

准备
类变量是被static修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象分配在java堆中。（实例化不是类加载
的一个过程，类加载发生在所有的实例化操作之前，并且类加载只进行一次，实例化可以进行多次）。
主意：类变量是常量直接赋值，就是final修饰。


解析：将常量池的符号替换为直接引用的过程。？？？？？？？？？？？这个不懂

初始化： 虚拟机执行类构造器<clinit>()方法的过程。
在准确阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。

<clinit>()方法具有以下特点：
1：是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集顺序由语句在源文件
中出现的顺序决定，特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。
2：与类的构造函数（或者说实例构造器<init>())不同，不需要显示的调用父类的构造器，虚拟机会自动保证在子类的<clinit>()
方法运行之前，父类<clinit>()方法已经执行结束，因此虚拟机中第一个执行<clinit>()方法的类肯定为java.lang.Object.
3:由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。
4：<clinit>（）对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对应类变量的赋值操作，编译器可以不
为该类生成<clinit>()方法
5：接口中不可以使用静态语句块，但仍然有类变量初始化赋值操作，因此接口与类一样都会生<clinit>()方法，但接口与类不同
的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。
6：虚拟机会保证一个类的<clinit>()方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有个线程
执行这个类的<clinit>()方法，其他线程都会阻塞，直到活动线程执行该方法完毕，如果一个类的<clinit>()方法中有耗时的操作，
就可能造成多个线程阻塞，在实际中这中阻塞很隐蔽。

类加载器：实现类的加载动作，在java虚拟机外部实现，以便应用程序自己决定如何获取所需要的类。

类和类加载器
两个类相等：类本身相等，并且使用同一个类加载器进行加载，这是因为每一个类加载器都拥有一个独立的类名称空间。

为什么不继承AppClassLoader呢？
答：因为它和ExtClassLoader都是Launcher的静态类，都是包含访问路径权限的。

怎么自定义类加载器：
1：继承ClassLoader
2:重写findClass方法
3：调用defineClass方法
作用：jvm自带的三个类加载器只能加载指定路径下的类字节码，如果某个情况下，我们需要加载应用程序之外的类文件，
这个时候就使用到了自定义加载器。












SPI服务提供接口，它是JDK内置的一种服务发现机制（不是微服务的服务发现啊），它可以让服务与实现分离，解耦，大大提升了
程序的扩展性。
Java在核心类库中定义了许多接口，并且还给出了针对这些接口的调用逻辑，然而并未给出实现，开发者要做的是定制一个实现类
在MATA-INF/services中注册实现类信息，以供核心类库使用。

SPI具体约定
当服务的提供这提供了服务接口的一种实现之后，在jar包的MATA-INF/services/目录里同时创建一个以服务接口命名的文件，该文件
里就是实现该服务接口的接替实现类，而外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到
具体的实现类名，并装载实例化，完成模块的注入，基于这样一个约定就能很好的找到服务接口的实现类，而不需要代码里制定，






为什么说SPI破坏可双亲委派机制：
Jdk只能提供一个贵伐接口，而不能提供实现，提供实现的是实际的数据库提供商，提供商的库总不能放Jdk目录里。
java从1.6搞出了SPI就是为了优雅的解决这类问题-JDK提供接口，供应商提供服务，编程人员编程时面相接口编程，然后JDK
能够自动找到合适的实现。但是遍历的同时也带来了困扰，提供商提供的类不能放JDK里的lib目录下，所以没法用BootstrapClassLoader加载。


双亲委派原则本身并非jvm强制模型
SPI的调用方和接口定义方很可能都在java的核心类库之中，而实现类交由开发者实现，然而实现类并不会被启动类加载器所加载，
基于双球委派的可见性原则，SPI调用无法拿到实现类。Spi通过线程上下文获取能够加载实现类的classLoader,一般情况下是application
classloader，绕过可这层逻辑，逻辑上打破了双亲委派原则。
类加载器的可见性原则：
假定A作为B的parent，A加载的类对B是可见的，然而B加载的类对A 是不可见的，父对子可见，子对父不可见。

三色标记法在并行回收的时候用。
黑 灰 白


可停顿时间是怎么维护的，怎么实现的？
g1垃圾收集器会跟踪每个region里面垃圾堆积的价值（即回收该region所需的空间和所需要的时间），然后再维护一个
优先级列表，每次根据优先级列表进行回收





















=IF(MATCH(F2,A:A,0)=MATCH(E2,B:B,0),C2,"-1")





























=IF(AND(A2=F2,B2=E2),C2-D2,"no")

INDEX(A$1:A$6,2)

match(A2,F:F,0)

=IF(AND(match(A1,F:F,0),match(B1,E:E,0)),




=INDEX(E:E,MATCH(A1&B1,J:J,0))








































