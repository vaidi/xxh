内存模型
 堆  栈  本地方法栈  程序计数器 方法区。
栈（虚拟机方法栈）：每个方法执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息，每一个方法被调用的过程就
对应一个栈帧在虚拟机栈中从入栈到出栈的过程。
局部变量表：是一片逻辑连续的内存空间，最小单位是slot，用来存放方法参数和方法内部定义的局部变量，
操作栈：每个栈帧都包含了一个被叫做操作数栈的后进先出的栈。通常情况下，操作数栈指的就是当前栈帧的 操作数栈。
作用：
 1：栈帧刚创建时，里面的操作数栈是空的，
 2：java虚拟机提供指令来让操作数栈对一些数据进行入栈操作，比如可以把局部变量表里的数据，实列的字段等数据入栈。
 3：同时也有指令来支持出栈操作
 4：向其他方法传参的参数，也存在操作数栈中
 5：其他方法返回的的结果，返回在操作数栈中


局部变量表所需要的内存空间在编译器完成分配，当进入一个方法时，这个方法在栈中需要分配多大的局部变量 空间是完全确定的，在方法
运行期间不会改变局部变量表的大小。

堆：java虚拟机管理内存最大的一区域，因为堆块内存存放的对象是线程共享的，所以多线程的时候也需要同步机制。
即时编译器：可以把java的字节码，包括需要被解释的指令的程序转换成可以直接发送给处理器的指令程序。
逃逸分析：通过逃逸分析来决定某些实列或者变量是否在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，
而非堆上分配，这些变量的指针可以被全局所引用，或者其他线程所引用。

方法区：  已经被虚拟机类加载的类信息  常量  静态变量  即时编译器编译后的代码
详细的来说方法区放着类的版本，字段，方法，接口和常量池。常量池里储存这字面量和符号引用。


特点：线程共享  内存回收率低  Java虚拟机规范对方法区的要求比较宽松。


运行时常量池：1.7后从方法区移出，在堆中开辟了一块区域存放运行时常量池。








对象的创建过程
1：虚拟机在解析.class文件时，若遇到一条new指令，首先它会检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否
已被加载，解析和初始化过，如果没有，那么必须先执行相关的类加载过程。

为新生对象分配内存：
1：指针碰撞  如果java堆中内存绝对规整（采用的复制算法或标记整理算法），空闲内存和已使用内存中间放着一个指针作为分界点指示器，
那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配的方式称为“指针碰撞”
2：空闲列表：如果java堆中内存并不规整，已使用的内存和空闲内存交错（采用标记-清楚算法，有碎片），此时没法简单进行指针碰撞，vm
必须维护一个列表，记录其中那些内存块空闲可用，分配之时从空闲列表中找到一块足够大的内存空间分给对象实列。
初始化：分配内存后，为对象中的成员变量赋值上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。

对象的访问方式：直接访问方式：引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象，但对象所在的内存空间
需要额外的策略存储对象所属的类信息的地址。







对象的内存布局：1：对象头  2：实例数据  3：对齐填充
对象头：markword很像网络协议报文头，划分为多个区间，并且会根据对象状态复用自己的存储空间。
实例数据：存放对象程序中各种类型的字段类型，不管是从父类中继承下来还是子类中定义的，分配策略：相同宽度字段总是 放在一起。
对其填充：对象大小必须是8的倍数，这个就是为了满足 jvm要求。

堆:
1:新生代
2：老年代
3：永久代  1.8后元空间不在堆中 元空间的内存就是直接内存了而不再是堆内存，元空间使用的是本地内存

元空间相关？？？？？？？
为什么要在直接内存里拿出来一块内存作为元空间取代永久代？
1：类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
2：永久代会为GC带来不必要的复杂度，并且回收效率偏低。
3：方便分配管理，因为直接内存空间比较充足，便于回收，因为永久代本来回收垃圾的事件发生概率很低，直接内存提高效率。





判断对象存活算法
1：引用计数算法   不足互相引用
2：可达性分析算法（GCROOT） 基本思路是通过GC Roots的对象为起始点，搜索所经过的路径称为引用链
当一个对象到GC Roots没有任何引用跟它连接起来则证明是不可用的。四种情况。
1：虚拟机栈中的引用的对象，就是平时所指的java对象，存放在堆中。
2：方法区中的类静态属性引用的对象，一般指static修饰引用的对象，加载类的时候就加载到内存中。
3：方法区中常量引用的对象，
4：本地方法栈中JNI（native方法）引用的对象。
真正宣告对象死亡的需要两个过程：
1:可达性分析后没有发现引用链
2：查看对象是否有finalize方法，如果有重写且在方法内完成自救{比如再建立引用}，还是可以抢救一下
，注意这边一个类的finalize只执行一次，这就会出现一样的代码第一次自救成功第二次失败。


GC Roots并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。
引用的分类：
1：强引用：垃圾回收器永远不会回收被引用的对象
2：软引用：通常用来实现内存敏感的缓存，如果空闲内存就可以暂时保留缓存，当内存不足时清理掉，这样保证了使用缓存的同时不会耗尽内存。
3：弱引用：强度比软引用更弱一些，当jvm进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象。
4：虚引用：也称幽灵引用或者幻影引用，一个对用是否有虚引用的存在，完全不会对其生存时间构成影响，它仅仅提供了一种确保对象被finalize
以后做某些事情的机制，比如通常用来做所谓的post-mortem清理机。

虚引用主要用来跟踪对象被垃圾回收的活动。






finalize（）是object中的方法，当垃圾回收器将要回收对象所占用之前被调用，即当一个被虚拟机宣告死亡时会先调用它的finalize方法，让此对象
处理它生前最后的事情。任何一个对象的finalize方法只会被系统调用一次，如果对象面临下次被回收，它的finalize方法不会被再次执行，想在这个
方法中进行自救就会失败。
如果对象被判定为有必要执行finalize（）方法，那么对象会被放入一个F-Queue队列中，虚拟机会以较低的优先级执行这戏额finalize（）方法，但不会
确保所有的finalize（）方法都会执行结束，如果finalize（）方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。





判定一个类是不是无用的类：
1：该类所有对象都被清楚
2：加载该类的ClassLoader已经被回收
3：该类的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射调用改类的方法
一个类被虚拟机加载进方法区，那么在堆中就 会有一个代表该类的对象：java.lang.Class，这个对象在类被加载进方法区时创建，在方法区该类删除。





GC算法
1：新生代采用复制算法 GC开始对象只会存于Eden和From Survivor 区域，To Survivor(保留空间)为空 gc进行时
Eden 区所有存活的对象都被复制到To Survivor 区 ，而From Survivor 区中，仍存活的对象会根据它们的年龄决定去向，年龄只达到
年龄阈值（默认15是对象头中的年龄站4bit，新生代每熬过一次垃圾回收，年龄+1），则移到老年代，没有达到则复制到To Survivor。
2：老年代采用标记清楚算法  或标记整理算法


标记-清除算法不足：
1：效率问题，标记和清除两个过程的效率都不高
2：形成大量不连续的内存碎片

复制算法：优点：不产生碎片 缺点：占用空间

标记-整理：  整理：移动所有存活的对象且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收，这是一种老年代收集算法。



垃圾收集器：垃圾回收算法是内存回收方法论，那么垃圾收集器就是具体实现，


CMS收集器：（标记清除算法）是一种获取最短回收停顿时间为目标的收集器。（并发收集，低停顿）四个阶段
1：初始标记：标记一下GC roots能直接关联到的对象，速度很快，
暂停所有线程stw，并记录下直接与root相连的对象速度很快。
2：并发标记：GC roots tracing过程，即可达性分析。
同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有可达的对象
，因为用户线程可能会不断的更新引用域，所以gc线程无法保证可达性分析的实性，所以这个算法里会跟踪记录这戏额会发生引用更新的地方。

3：重新标记：为了修正因并发表期间用户程序运作而产生变动的那一部分标记记录，会有许停顿。
重新标记就是为了修正并发标记期间因为用户程序运行而导致标记h残生变动的那一部分对象的标记记录，这个阶段的停顿
时间一般会比初始标记阶段时间稍长，远远比并发标记阶段时间短。

4：并发清楚 ：开启用户线程，同时gc线程开始为标记的区域做清扫。

初始标记和重新标记需要stw。
缺点： cms对cpu特别敏感，cms运行线程和应用程序并发执行需要多核cpu，如果cpu核数多的话可以发挥他并发
执行的优势，受cpu影响大，cpu小的话可能影响到计算机性能。
2：无法处理浮动垃圾。可能导致并发模式故障而触发fullgc，浮动垃圾：由于cms支持运行的时候用户线程也在运行，程序运行的时候会
产生新垃圾，这里产生的垃圾就是浮动垃圾。
3：“标记-清除”算法产生垃圾碎片。可以选择参数开启内存整理，内存整理内存碎片，内存整理是无法并发的，影响性能


G1收集器：
 g1收集器（garbage first：尽可能多收垃圾，避免full gc），是用于替代cms功能更为强大的新型收集器，因为它解决了cms产生的空间碎片问题。
问题：
一个对象和他内部所引用的对象可能不在同一个Region中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？
并不！每个region都有一个remember set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在GC Roots中再加上r set即
可防止对整个堆内存进行遍历。
G1的工作步骤：
1：初始标记：stw 仅使用一条初始标记线程对所有与GC Roots直接关联的对象进行标记。
2：并发标记：使用一条标记线程 与用户线程并发执行，此过程进行可达性分析，速度很慢
3：最终标记：stw 使用多条线程并发执行
4：筛选回收：回收废弃对象，此时Stw，并使用多条筛选回收线程并发执行。




特别之处：强化了分区，弱化了分带的概念，是区域化，增量式的收集器它不属于新生代也不属于老年代的收集器
算法：标记-清零  复制算法
g1 通过并发（并行）标记阶段查找老年代存活对象，通过并行复制压缩存活对象【这样可以省出连续空间供大对象使用】
g1 将一组或多组区域汇总存活对象以增量并行的方式复制到不同区域进行压缩，从而减少堆碎片，目标尽可能多回收堆空间【垃圾优先】
且尽可能不超出暂停目标以达到延迟的目的。
g1 提供三种回收模式 young gc，mix gc 和full gc，不像其他收集器，根据区域而不是分代，新生代老年代的对象他都能回收。


GC是怎么判断对象是被标记的：通过枚举根节点的方式，通过jvm提供的一种oopMap的数据结构，简单的来说就是不要再通过去遍历内存的东西，而是通过OOPmap
把栈上代表引用的位置全部标记下来。总结：通过OOPMap把栈上代表引用的位置全部记录下来，避免全栈扫描，加快枚举根节点的速度，除此自外还有一个极为
重要的作用，可以帮HotSpot实现准确GC【这边的准确关键就是类型，可以根据给定位置的某块数据知道它的准确类型，HotSpot是通过oopMap外部记录下这戏额信息，存成 映射表一样东西】

什么时候处罚GC:
minor GC(young GC):当年轻代中eden区分配满的时候触发[值得一提的是因为young GC后部分存活的对象会已到老年代(比如对象熬过15轮)，所以过后old gen的占用量通常会变高]

full GC:
①手动调用System.gc()方法 [增加了full GC频率，不建议使用而是让jvm自己管理内存，可以设置-XX:+ DisableExplicitGC来禁止RMI调用System.gc]
②发现perm gen（如果存在永久代的话)需分配空间但已经没有足够空间
③老年代空间不足，比如说新生代的大对象大数组晋升到老年代就可能导致老年代空间不足。
④CMS GC时出现Promotion Faield[pf]
⑤统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间。
这个比较难理解，这是HotSpot为了避免由于新生代晋升到老年代导致老年代空间不足而触发的FUll GC。
比如程序第一次触发Minor GC后，有5m的对象晋升到老年代，姑且现在平均算5m，那么下次Minor GC发生时，先判断现在老年代剩余空间大小是否超过5m，
如果小于5m，则HotSpot则会触发full GC(这点挺智能的)

空间分配担保：就是确保老年带的空间能够冗余新生代minor gc后所有还存活的对象，不然的会触发fullgc。
通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代做担保，这个过程就是分配担保。


大对象直接进入老年代：大对象需要大量的连续的内存空间（比如：字符串，数组），为了避免大对象分配内存时由于分配担保机制带来的复制效率降低。




新生代什么情况下会晋升到老年代（对象晋升规则）：
1:长期存活的对象进入老年代，对象每熬过一次GC年龄+1（默认阈值15，可配置）
2：对象太大，新生代无法容纳会分配到老年代
3：eden区满了，进行minor gc后，eden和一个survivor区仍然存活的对象无法放到to区则会通过分配担保机制放到老年代，这种情况一般是minor gc后新生代存活对象太多
4：动态年龄判断：相同年龄对象大于幸寸区的一半吗，这写对象monir gc时移动到老年代








类加载：
1：加载
将.class文件加载到内存
将静态数据结构转化成方法区中运行时的数据结构
在堆中生成一个代表这个类的java.lang.Class对象作为数据访问的入口。
       2：验证  确保加载的类符合JVM规范和安全，保证被校验类的方法在运行的时不会做出危害虚拟机的事件，就是一个安全检查
链接   3：准备  为static变量在方法区中分配内存空间，设置变量的初始值，例如static int a =3（注意：准备阶段只设置类中的静态
		变量（方法区中），不包括实列变量（堆内存中），实例变量时对象初始化时赋值的）
       4：解析  虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在 import java.util.ArrayList这就算符号引用
		，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）
5：初始化  就是一个赋值操作，它会执行一个类构造器的<clinit>方法。由编译器自动收集类中所有变量的赋值操作，此时准备阶段事的那个
	   static int a = 3，这个时候就正式赋值为3；
6：使用
7：卸载  gc将无用对象内存中卸载


一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去
控制字节流的获取方式（重写一个类 加载器的loadClass（）方法），数组类型不通过 类加载器 创建，它 由java虚拟机直接创建。
加载 阶段和链接阶段的部分内容是交叉进行的，加载尚未结束，链接阶段可能已经开始了。
准备 ：准备阶段 是 正式 为类变量分配内存并设置 类变量初始值 的阶段，这些内存都将在方法区中 分配。






5种情况必须初始化：（主动引用）
1：在遇到new，pustatic，getstatic，invokestatic字节码指令时，如果类尚未初始化，则需先触发其初始化
2：对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化
3：初始化一个类时，如果其父类还没初始化，则需要先初始化父类。
4：虚拟机启动时，用于需要特指定一个包含main（）方法的主类，虚拟机会先初始化这个类。






















